<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0061)http://www.cs.umd.edu/class/fall2017/cmsc430/assignment2.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=0.8"><title>Assignment 2: Desugaring (project)</title><link rel="stylesheet" type="text/css" href="./Assignment 2_ Desugaring (project)_files/scribble.css" title="default"><link rel="stylesheet" type="text/css" href="./Assignment 2_ Desugaring (project)_files/manual-style.css" title="default"><link rel="stylesheet" type="text/css" href="./Assignment 2_ Desugaring (project)_files/manual-racket.css" title="default"><script type="text/javascript" src="./Assignment 2_ Desugaring (project)_files/scribble-common.js"></script><script type="text/javascript" src="./Assignment 2_ Desugaring (project)_files/manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">►</a></td><td></td><td><a href="http://www.cs.umd.edu/class/fall2017/cmsc430/assignment2.html" class="tocviewselflink" data-pltdoc="x">Assignment 2:<span class="mywbr"> &nbsp;</span> Desugaring (project)</a></td></tr></tbody></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right"></td><td><a href="http://www.cs.umd.edu/class/fall2017/cmsc430/assignment2.html#%28part._.Getting_started%29" class="tocviewlink" data-pltdoc="x">Getting started</a></td></tr></tbody></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tbody><tr><td><span class="tocsublinknumber"></span><a href="http://www.cs.umd.edu/class/fall2017/cmsc430/assignment2.html#%28part._.Assignment_2__.Desugaring__project_%29" class="tocsubseclink" data-pltdoc="x">Assignment 2:<span class="mywbr"> &nbsp;</span> Desugaring (project)</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="http://www.cs.umd.edu/class/fall2017/cmsc430/assignment2.html#%28part._.Getting_started%29" class="tocsubseclink" data-pltdoc="x">Getting started</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="http://www.cs.umd.edu/class/fall2017/cmsc430/assignment2.html#%28part._.Some_advice%29" class="tocsubseclink" data-pltdoc="x">Some advice</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="http://www.cs.umd.edu/class/fall2017/cmsc430/assignment2.html#%28part._.Extra_.Credit%29" class="tocsubseclink" data-pltdoc="x">Extra Credit</a></td></tr></tbody></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">6.10</span></div><h2><a name="(part._.Assignment_2__.Desugaring__project_)"></a>Assignment 2: Desugaring (project)</h2><p>Your task on Assignment 2 is to write a desugaring pass for the class project.
You are building a compiler pass for an input language with a number of forms including
exceptions, dynamic-wind, call/cc, first-class primitives, etc.
The pass yields terms in a small core language including only a let form, the lambda-calculus,
conditionals, set!, call/cc, and explicit primitive-operation forms.</p><p>Input language:</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="stt">e ::= (letrec* ([x e] ...) e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (letrec ([x e] ...) e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (let* ([x e] ...) e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (let ([x e] ...) e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (let x ([x e] ...) e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (lambda (x ...) e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (lambda x e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (lambda (x ...+ . x) e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (dynamic-wind e e e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (guard (x cond-clause ...) e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (raise e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (delay e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (force e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (and e ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (or e ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (cond cond-clause ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (case e case-clause ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (if e e e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (when e e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (unless e e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (set! x e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (begin e ...+)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (call/cc e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (apply e e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (e e ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| x</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| op</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (quote dat)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">cond-clause ::= (e) | (e e) | (else e)</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">; in all test cases</span></p></td></tr><tr><td><p><span class="stt">case-clause ::= ((dat ...) e) | (else e)</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">; else clauses always come last</span></p></td></tr><tr><td><p><span class="stt">dat is a datum satisfying datum? from utils.rkt</span></p></td></tr><tr><td><p><span class="stt">x is a variable (satisfies symbol?)</span></p></td></tr><tr><td><p><span class="stt">op is a symbol satisfying prim? from utils.rkt (if not otherwise in scope)</span></p></td></tr><tr><td><p><span class="stt">op ::= promise? | null? | cons | car | + | ...</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(see utils.rkt)</span></p></td></tr></tbody></table><p></p><p>Output language:</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="stt">e ::= (let ([x e] ...) e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (lambda (x ...) e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (lambda x e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (apply e e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (e e ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (prim op e ...)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (apply-prim op e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (if e e e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (set! x e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (call/cc e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| x</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| (quote dat)</span></p></td></tr></tbody></table><p></p><p>The <a href="http://www.cs.umd.edu/class/fall2017/cmsc430/assignment2_starter.tar.gz">assignment 2 starter</a>
<span style="font-style: italic">contains a file</span> <span class="stt">utils.rkt</span> which provides some useful functions and a
specification for the input and output languages in the form of two predicates <span class="stt">scheme-exp?</span>
and <span class="stt">ir-exp?</span>. You can also use the functions <span class="stt">eval-scheme</span> and <span class="stt">eval-ir</span> to evaluate
programs that are in each of these languages.</p><p>Your job is to write your own set of unit tests and define a translation function <span class="stt">desugar</span>,
provided in a file <span class="stt">desugar.rkt</span>, that simplifies programs satisfying <span class="stt">scheme-exp?</span> into
programs satisfying <span class="stt">ir-exp?</span> that are (if they don’t error) semantically equivalent according
to <span class="stt">eval-scheme</span> and <span class="stt">eval-ir</span>.</p><p>Although basic forms and primitive operations can be shadowed in Scheme/Racket, you may assume tests
never redefine or shadow symbols matching either <span class="stt">prim?</span> or <span class="stt">reserved?</span> (also from <span class="stt">utils.rkt</span>).
Handling this properly is worth extra credit (see below).</p><h3><a name="(part._.Getting_started)"></a>Getting started</h3><p>For your assignment you may use the stubbed out code and tests linked above. A small number
of tests are provided, but to do well on the assignment you will mostly need to write your own tests.
You should turn in a desugar.rkt file that provides a <span class="stt">desugar</span> function. It may be helpful
to require the <span class="stt">utils.rkt</span> module and make use of functions like <span class="stt">prim?</span> and <span class="stt">prims-&gt;list</span>.</p><p></p><table cellspacing="0" cellpadding="0"><tbody><tr><td><p><span class="stt">#lang racket</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">; by First Last</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">(provide desugar)</span></p></td></tr><tr><td><p><span class="stt">(require "utils.rkt")</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">(define (desguar-aux e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(match e ...))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">(define (desugar e)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; wrap e in any special functions or definitions you need</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; and then pass it into a helper function that performs the</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">; case-by-case translation recursively</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(desugar-aux (wrap-with-definitions e)))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">; I, First Last, pledge on my honor that I have not given or received any unauthorized</span></p></td></tr><tr><td><p><span class="stt">; assistance on this project.</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr></tbody></table><p></p><p>I recommend you get started by writing simple cases for forms that are both in the source language and
target language (such as <span class="stt">let</span>, <span class="stt">lambda</span>, and <span class="stt">if</span>), testing that you can pass very simple inputs
that are in both languages first. Then you can build up to desugaring forms like <span class="stt">unless</span> and <span class="stt">cond</span>.</p><h4><a name="(part._.Some_advice)"></a>Some advice</h4><ul><li><p>(NEW) See the end of the CEK slides (refresh to get latest version) or the note on Piazza
for the implementation of dynamic-wind and call/cc. The slides also show an outline for the implementation
of raise and guard.</p></li><li><p>I recommend you get started by supporting forms that match <span class="stt"></span><span class="stt">‘</span><span class="stt">(,(? prim?) ,es ...)</span>
and <span class="stt"></span><span class="stt">‘</span><span class="stt">(quote ,(? datum?))</span>—<wbr>this will be enough to pass test <span class="stt">start-0</span> which should desguar to
<span class="stt"></span><span class="stt">’</span><span class="stt">(prim + </span><span class="stt">’</span><span class="stt">2 </span><span class="stt">’</span><span class="stt">3)</span>.
Then you can support trivially recuring over all the other forms in the target language
(e.g., for a pass <span class="stt">t</span>, <span class="stt">(t </span><span class="stt">‘</span><span class="stt">(if ,e0 ,e1 ,e2))</span> yields <span class="stt"></span><span class="stt">‘</span><span class="stt">(if ,(t e0) ,(t e1) ,(t e2))</span>) which will be enough to support
test <span class="stt">start-1</span>. From here you can work on writing new tests and extending your desugarer to
support other features of the input language.</p></li><li><p>Any <span class="stt">*.scm</span> file added to <span class="stt">tests/public/</span>, <span class="stt">tests/release/</span>, or <span class="stt">tests/secret/</span> will be
treated as a test. Add a file like <span class="stt">mytest.scm</span> and run <span class="stt">racket tests.rkt mytest</span> to test it.</p></li><li><p>Remember when writing tests that all datums must be explicitly quoted (except in the <span class="stt">case</span> form).
This means that <span class="stt">(+ 1 2)</span> is an invalid input, but <span class="stt">(+ </span><span class="stt">’</span><span class="stt">1 </span><span class="stt">’</span><span class="stt">2)</span> is valid.</p></li><li><p>The function <span class="stt">gensym</span> can be used to generate fresh variable names. This appends a number
to the symbol provided to produce a fresh symbol; e.g., <span class="stt">(gensym </span><span class="stt">’</span><span class="stt">tmp)</span> =&gt; <span class="stt"></span><span class="stt">’</span><span class="stt">tmp3276</span>.</p></li><li><p>Use <span class="stt">(prim-&gt;list)</span> to obtain a list of primitives you can use. You can use <span class="stt">(prim void)</span> to return a void value.</p></li><li><p>You will need to desugar all primitive operations into explicit <span class="stt">prim</span> and <span class="stt">apply-prim</span> forms.
So for example, you must desugar primitives passed as arguments into lambdas (eta-expanding them). E.g.
<span class="stt"></span><span class="stt">’</span><span class="stt">((lambda (f) (f </span><span class="stt">’</span><span class="stt">2 </span><span class="stt">’</span><span class="stt">3 </span><span class="stt">’</span><span class="stt">4)) +)</span> could desugar into <span class="stt"></span><span class="stt">’</span><span class="stt">((lambda (f) (f </span><span class="stt">’</span><span class="stt">2 </span><span class="stt">’</span><span class="stt">3 </span><span class="stt">’</span><span class="stt">4)) (lambda args (apply-prim + args)))</span>.</p></li><li><p>It doesn’t matter how you encode promises as long as your <span class="stt">promise?</span> function distinguishes them properly (you might use a unique tag inside a list to ensure this). Don’t emit <span class="stt"></span><span class="stt">‘</span><span class="stt">(prim promise? x)</span>, but replace it with code that checks your own encoding of promises.
You also need to ensure that the value forced is saved; try <span class="stt">vector-set!</span> for this.</p></li><li><p>At first you may desugar <span class="stt">call/cc</span> directly into <span class="stt">call/cc</span>, but ultimately a correct desugaring of <span class="stt">call/cc</span>
will require <a href="http://www.scheme.com/tspl2d/control.html#g1978">cooperation with</a> <span class="stt">dynamic-wind</span> as we’ll discuss in class.</p></li><li><p>You will need to turn lambdas such as <span class="stt">(lambda (a . b) ...)</span> into lambdas that take an argument list such as
<span class="stt">(lambda t (let ([a (car t)][b (cdr t)]) ...))</span></p></li></ul><h4><a name="(part._.Extra_.Credit)"></a>Extra Credit</h4><p><span style="font-style: italic">Extra credit opportunity</span>: You do not need to correctly handle shadowing of primitive operations or language
forms such as <span class="stt">let</span>, <span class="stt">letrec</span>, or <span class="stt">cons</span>. You may assume that none of the binding forms in input programs will
redefine these identifiers. There are several extra-credit release tests which do—<wbr>such as <span class="stt">ec-shadowing-0</span>—<wbr>and
you can try satisfying them for bonus points. I recommend you write a version which works for other tests first
and only then extend it to pass these tests by passing an environment of bound ids.</p><p>There is also a test ec-letcc that will test a <span class="stt">(let/cc x e)</span> expression you can implement for a few extra points. If trying this last form, download the latest version of utils.rkt so scheme-exp? will accept it. (Each of the 5 extra credit tests are worth +3%.)</p></div></div><div id="contextindicator">&nbsp;</div><p style="text-align: right;"><a href="https://www.umd.edu/web-accessibility" title="UMD Web Accessibility">Web Accessibility</a></p>
</body></html>